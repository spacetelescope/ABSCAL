:mod:`abscal.common.utils`
==========================

.. py:module:: abscal.common.utils

.. autoapi-nested-parse::

   This module includes general utility functions.

   Authors
   -------
   - Brian York

   Use
   ---
   Individual functions from this module are intended to be imported where
   needed::

       from abscal.common.utils import absdate



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   abscal.common.utils.absdate
   abscal.common.utils.get_base_data_dir
   abscal.common.utils.get_data_file
   abscal.common.utils._extract_dict
   abscal.common.utils.get_defaults
   abscal.common.utils.set_param
   abscal.common.utils.set_params
   abscal.common.utils.set_image
   abscal.common.utils.air2vac
   abscal.common.utils.smooth_model
   abscal.common.utils.trapezoidal
   abscal.common.utils.integral
   abscal.common.utils.tabinv
   abscal.common.utils.linecen



.. function:: absdate(pstrtime)

   Get the date in decimal years.

   This is used to figure out a target position, given that we have the target
   co-ordinates, the co-ordinate epoch, the annual proper motion, and the observation
   time.

   :param pstrtime: The observation start time
   :type pstrtime: str or Time or datetime

   :returns: **dt** -- The observation year + fractional (decimal) year
   :rtype: float


.. function:: get_base_data_dir()

   Find the location of the ABSCAL data files.

   ABSCAL stores both default parameters and exposure-specific corrections and settings
   in a number of data files. There are default copies stored internally, but they can
   also be stored elsewhere. The ABSCAL_DATA environment variable points to that
   location, although there is always a fallback to local data if a specified file does
   not exist elsewhere.

   :returns: **data_dir** -- The directory pointed to by ABSCAL_DATA (if both the environment variable and
             the directory to which it points exist)
   :rtype: str


.. function:: get_data_file(module, fname, defaults=False)

   Find an internal data file.

   Returns the path to a file named `fname` in the data directory of the
   (sub)module named `module`. Keeps there from being a lot of repetitive code in order
   to find data file paths.

   :param module: The module to search in, using standard dot separators (e.g.
                  abscal.wfc3)
   :type module: str
   :param fname: The file name of interest
   :type fname: str
   :param defaults: Whether to append a "defaults" directory to the final path
   :type defaults: bool, default False

   :returns: **data_file** -- Full path to the data file. If no file is found at the generated path, None will
             be returned. This is not necessarily a failure state, because (for example) a
             function may call for a known-issues file even though there are no current known
             issues (and thus no file to return). This way, the code doesn't need to be
             changed when there *is* a file, and a user can add a file to their local directory
             without needing to alter the code, because the code will just transparently find
             the file.
   :rtype: str or None


.. function:: _extract_dict(input_dict, output_dict, input_keys)

   Recursively extract values from a defaults dictionary.

   A defaults dictionary consists of:

   - an optional "all" key
   - zero or more other keys, each of whose values is a defaults dictionary

   The goal is to add any matching values to an output dictionary, with more specific
   matching values overriding less specific matching values. As such, given an input
   dictionary and a list of keywords,

   - Add all key/value pairs from the "all" dictionary (if present) to the output
     dictionary.
   - For each keyword in the list, if that keyword is in the dictionary, call this
     function recursively on the value of that key, which is (see above) a dictionary.
   - Don't check on whether a value already exists in the output dictionary, because
     more-specific overrides less-specific (if you need a default for a specific value to
     definitely override a more general default, nest that value as a keyword inside the
     more general dictionary).

   :param input_dict: The dictionary to search
   :type input_dict: dict
   :param output_dict: The dictionary to build from
   :type output_dict: dict
   :param input_keys: A list of keys to search for
   :type input_keys: list

   :returns: **output_dict** -- The edited output dictionary
   :rtype: dict


.. function:: get_defaults(module, *args)

   Find an internal defaults data file, load it using YAML, and return the resulting
   dictionary.

   Takes the dot-separated module path (e.g. "abscal.wfc3.reduce_grism_extract"), splits
   off the last item (e.g. ["abscal.wfc3", "reduce_grism_extract"]), adds ".yaml" to the
   end of the second item (e.g. ["abscal.wfc3", "reduce_grism_extract.yaml"]), adds
   ".defaults" to the first item
   (e.g. ["abscal.wfc3.defaults", "reduce_grism_extract.yaml"]), and feeds the result
   into :code:`get_data_file()`. Then loads the resulting file as a dictionary, and
   builds a new dictionary consisting of:

   - All key/value pairs in the "all" dictionary
   - All key/value pairs in any dictionary matching any of the keyword arguments
   - The above two items from any dictionary matching any of the keyword arguments,
     extending recursively into the depths of the dictionary.

   The result will be a flat (i.e. single-level) dictionary.

   :param module: The module to search in, using standard dot separators (e.g. abscal.wfc3)
   :type module: str
   :param args: A list of specific keyword arguments, provided to ensure the inclusion of
                specific sub-values or sub-dictionaries.
   :type args: list

   :returns: **defaults** -- Dictionary of default parameters.
   :rtype: dict


.. function:: set_param(param, default, row, issues, pre, overrides={}, verbose=False)

   Set a parameter value

   Given a parameter name, that parameter's default value, a data table
   row, and a JSON dictionary which may have an entry for the current row that
   will override the parameter, return the parameter value that should be used.

   :param param: The parameter to check and return
   :type param: str
   :param default: The default value for that parameter
   :type default: object
   :param row: A single-row table containing the data of interest.
   :type row: abscal.common.exposure_data_table.AbscalDataTable
   :param issues: A dictionary containing a set of parameters (one of which may be
                  param), along with information to identify files whose parameters
                  should be adjusted .
   :type issues: dict
   :param overrides: A dictionary containing any parameters whose value is being overridden
                     by the user.
   :type overrides: dict
   :param verbose: Whether or not informational output should be printed.
   :type verbose: bool

   :returns: **value** -- The appropriate value for the parameter given
   :rtype: object


.. function:: set_params(defaults, row, issues, pre, overrides={}, verbose=False)

   Set multiple parameter values

   Given a dictionary of default values, a metadata row, a dictionary of
   known issues and overrides, a dictionary of user-supplied overrides,
   and a verbose flag, produce a dictionary of parameters (all with the
   appropriate value) which also contains a 'set' key (an array of all
   the parameters that have been overridden from their default values).

   :param defaults: A dictionary of default values (also names the parameters)
   :type defaults: dict
   :param row: A single-row table containing the data of interest.
   :type row: abscal.common.exposure_data_table.AbscalDataTable
   :param issues: A dictionary containing a set of parameters, along with information to
                  identify files whose parameters should be adjusted.
   :type issues: dict
   :param overrides: A dictionary containing any parameters whose value is being overridden
                     by the user.
   :type overrides: dict
   :param verbose: Whether or not informational output should be printed.
   :type verbose: bool

   :returns: **params** -- The supplied parameters, each with its value.
   :rtype: dict


.. function:: set_image(images, row, issues, pre, overrides={}, verbose=False)

   Update an image based on known issues.

   Given an image, image metadata, and a set of known issues, determine if any
   of the known issues apply to the image in question and, if they do, make
   the appropriate edits to the image.

   :param images: Dict of (SCI, ERR, DQ) np.ndarray images
   :type images: dict
   :param row: A single-row table containing metadata on the image
   :type row: abscal.common.exposure_data_table.AbscalDataTable
   :param issues: A dictionary containing a set of parameters, along with information to
                  identify files whose parameters should be adjusted.
   :type issues: dict
   :param overrides: A dictionary containing any parameters whose value is being overridden
                     by the user.
   :type overrides: dict
   :param verbose: Whether or not informational output should be printed.
   :type verbose: bool

   :returns: **image** -- Tuple of (SCI, ERR, DQ) np.ndarray images, as edited.
   :rtype: tuple


.. function:: air2vac(air)

   Convert a set of wavelengths from air to vacuum.

   :param air: Air wavelengths
   :type air: array-like

   :returns: **vac** -- Vacuum wavelengths
   :rtype: array-like


.. function:: smooth_model(wave, flux, fwhm)

   Smooth a model spectrum with a non-uniform sampling interval.

   Based on Ralph Bohlin's "smomod.pro", which itself references "tin.pro"

   :param wave: Wavelength array
   :type wave: array-like
   :param flux: Flux array
   :type flux: array-like
   :param fwhm: FWHM of delta function.
   :type fwhm: float

   :returns: **smoothed** -- Smoothed flux array.
   :rtype: array-like


.. function:: trapezoidal(wave, flux, wmin, wmax)

   Make a trapezoidal integral

   Trapezoidal 'integral' (really an average) from Ralph Bohlin's 'tin.pro'
   and 'integral.pro'. Uses wmin and wmax to set limits

   :param wave: Wavelength array
   :type wave: array-like
   :param flux: Flux array
   :type flux: array-like
   :param wmin: Wavelength array shifted bluewards by FWHM/2
   :type wmin: array-like
   :param wmax: Wavelength array shifted redwards by FWHM/2
   :type wmax: array-like

   :returns: **trapint** -- Flux array after trapezoidal integral
   :rtype: array-like


.. function:: integral(x, y, xmin, xmax)

   Return the approximate integral of y over x for the range (xmin, xmax)

   :param x: X value array
   :type x: array-like
   :param y: Y value array. Must be the same length as x
   :type y: array-like
   :param xmin: minimum x value for integral
   :type xmin: float
   :param xmax: maximum x value for integral
   :type xmax: float

   :returns: **int** -- integral value
   :rtype: float


.. function:: tabinv(xarr, x)

   Find the effective index in xarr of each element in x.

   The effective index for each element j in x is the value i such that
   :math:`xarr[i] <= x[j] <= xarr[i+1]`, to which is added an interpolation fraction
   based on the size of the intervals in xarr.

   :param x_arr: The array of values to search
   :type x_arr: array-like
   :param x: Value (or list of values) to look for in x_arr
   :type x: float or array-like

   :returns: **ieff** -- Effective index
   :rtype: float


.. function:: linecen(wave, spec, cont)

   Find the centre of an emission line.

   Computes the centroid of an emission line over the range of

   :math:
       xapprox \pm fwhm/2

   after subtracting any continuum and half value at the remaining peak. After
   clipping at zero, the weights of the remaining spectral wings approach zero,
   so any marginally missed or included point matters little.

   :param wave: 1-d array of x values
   :type wave: np.ndarray
   :param spec: 1-d array of y values
   :type spec: np.ndarray
   :param cont: Approximate continuum value
   :type cont: float

   :returns: * **centroid** (*float*) -- The x value of the centroid
             * **badflag** (*bool*) -- False for good data, true for bad data


